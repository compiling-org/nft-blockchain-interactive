{"version":3,"file":"index-b99eacc9.js","sources":["../../node_modules/@polkadot/util/u8a/cmp.js","../../node_modules/@polkadot/util/u8a/sorted.js","../../node_modules/@polkadot/networks/packageInfo.js","../../node_modules/@polkadot/x-randomvalues/packageInfo.js","../../node_modules/@polkadot/util-crypto/detectOther.js","../../node_modules/@polkadot/util-crypto/detectPackage.js","../../node_modules/@polkadot/util-crypto/address/addressToEvm.js","../../node_modules/@polkadot/util-crypto/address/check.js","../../node_modules/@polkadot/util-crypto/random/asNumber.js","../../node_modules/@polkadot/util-crypto/ed25519/pair/fromRandom.js","../../node_modules/@polkadot/util-crypto/ed25519/pair/fromSecret.js","../../node_modules/@polkadot/util-crypto/ed25519/pair/fromString.js","../../node_modules/@polkadot/util-crypto/sr25519/agreement.js","../../node_modules/@polkadot/util-crypto/sr25519/derivePublic.js","../../node_modules/@polkadot/util-crypto/address/derive.js","../../node_modules/@polkadot/util-crypto/address/keyDerived.js","../../node_modules/@polkadot/util-crypto/address/encodeDerived.js","../../node_modules/@polkadot/util-crypto/address/util.js","../../node_modules/@polkadot/util-crypto/address/keyMulti.js","../../node_modules/@polkadot/util-crypto/address/encodeMulti.js","../../node_modules/@polkadot/util-crypto/address/eq.js","../../node_modules/@polkadot/util-crypto/address/evmToAddress.js","../../node_modules/@polkadot/util-crypto/address/validate.js","../../node_modules/@polkadot/util-crypto/address/is.js","../../node_modules/@polkadot/util-crypto/address/sort.js","../../node_modules/@polkadot/util-crypto/base32/bs32.js","../../node_modules/@polkadot/util-crypto/base64/pad.js","../../node_modules/@polkadot/util-crypto/base64/trim.js","../../node_modules/@polkadot/util-crypto/mnemonic/generate.js","../../node_modules/@polkadot/util-crypto/hd/ledger/derivePrivate.js","../../node_modules/@polkadot/util-crypto/hd/ledger/master.js","../../node_modules/@polkadot/util-crypto/hd/ledger/index.js","../../node_modules/@polkadot/util-crypto/json/decrypt.js","../../node_modules/@polkadot/util-crypto/json/encrypt.js"],"sourcesContent":["import { u8aToU8a } from './toU8a.js';\n/**\n * @name u8aCmp\n * @summary Compares two Uint8Arrays for sorting.\n * @description\n * For `UInt8Array` (or hex string) input values returning -1, 0 or +1\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aCmp } from '@polkadot/util';\n *\n * u8aCmp(new Uint8Array([0x67, 0x65]), new Uint8Array([0x68, 0x65])); // -1\n * u8aCmp(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // 0\n * u8aCmp(new Uint8Array([0x69, 0x65]), new Uint8Array([0x68, 0x65])); // +1\n * ```\n */\nexport function u8aCmp(a, b) {\n    const u8aa = u8aToU8a(a);\n    const u8ab = u8aToU8a(b);\n    let i = 0;\n    while (true) {\n        const overA = i >= u8aa.length;\n        const overB = i >= u8ab.length;\n        if (overA && overB) {\n            // both ends reached\n            return 0;\n        }\n        else if (overA) {\n            // a has no more data, b has data\n            return -1;\n        }\n        else if (overB) {\n            // b has no more data, a has data\n            return 1;\n        }\n        else if (u8aa[i] !== u8ab[i]) {\n            // the number in this index doesn't match\n            // (we don't use u8aa[i] - u8ab[i] since that doesn't match with localeCompare)\n            return u8aa[i] > u8ab[i]\n                ? 1\n                : -1;\n        }\n        i++;\n    }\n}\n","import { u8aCmp } from './cmp.js';\n/**\n * @name u8aSorted\n * @summary Sorts an array of Uint8Arrays\n * @description\n * For input `UInt8Array[]` return the sorted result\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aSorted} from '@polkadot/util';\n *\n * u8aSorted([new Uint8Array([0x69]), new Uint8Array([0x68])]); // [0x68, 0x69]\n * ```\n */\nexport function u8aSorted(u8as) {\n    return u8as.sort(u8aCmp);\n}\n","export const packageInfo = { name: '@polkadot/networks', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '12.6.2' };\n","export const packageInfo = { name: '@polkadot/x-randomvalues', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '12.6.2' };\n","import { packageInfo as netInfo } from '@polkadot/networks/packageInfo';\nimport { packageInfo as utilInfo } from '@polkadot/util/packageInfo';\nimport { packageInfo as randomInfo } from '@polkadot/x-randomvalues';\nexport default [netInfo, utilInfo, randomInfo];\n","import { detectPackage } from '@polkadot/util';\nimport others from './detectOther.js';\nimport { packageInfo } from './packageInfo.js';\ndetectPackage(packageInfo, null, others);\n","import { decodeAddress } from './decode.js';\n/**\n * @name addressToEvm\n * @summary Converts an SS58 address to its corresponding EVM address.\n */\nexport function addressToEvm(address, ignoreChecksum) {\n    return decodeAddress(address, ignoreChecksum).subarray(0, 20);\n}\n","import { base58Decode } from '../base58/index.js';\nimport { checkAddressChecksum } from './checksum.js';\nimport { defaults } from './defaults.js';\n/**\n * @name checkAddress\n * @summary Validates an ss58 address.\n * @description\n * From the provided input, validate that the address is a valid input.\n */\nexport function checkAddress(address, prefix) {\n    let decoded;\n    try {\n        decoded = base58Decode(address);\n    }\n    catch (error) {\n        return [false, error.message];\n    }\n    const [isValid, , , ss58Decoded] = checkAddressChecksum(decoded);\n    if (ss58Decoded !== prefix) {\n        return [false, `Prefix mismatch, expected ${prefix}, found ${ss58Decoded}`];\n    }\n    else if (!defaults.allowedEncodedLengths.includes(decoded.length)) {\n        return [false, 'Invalid decoded address length'];\n    }\n    return [isValid, isValid ? null : 'Invalid decoded address checksum'];\n}\n","import { BN, hexToBn } from '@polkadot/util';\nimport { randomAsHex } from './asU8a.js';\nconst BN_53 = new BN(0b11111111111111111111111111111111111111111111111111111);\n/**\n * @name randomAsNumber\n * @summary Creates a random number from random bytes.\n * @description\n * Returns a random number generated from the secure bytes.\n * @example\n * <BR>\n *\n * ```javascript\n * import { randomAsNumber } from '@polkadot/util-crypto';\n *\n * randomAsNumber(); // => <random number>\n * ```\n */\nexport function randomAsNumber() {\n    return hexToBn(randomAsHex(8)).and(BN_53).toNumber();\n}\n","import { randomAsU8a } from '../../random/index.js';\nimport { ed25519PairFromSeed } from './fromSeed.js';\n/**\n * @name ed25519PairFromRandom\n * @summary Creates a new public/secret keypair.\n * @description\n * Returns a new generate object containing a `publicKey` & `secretKey`.\n * @example\n * <BR>\n *\n * ```javascript\n * import { ed25519PairFromRandom } from '@polkadot/util-crypto';\n *\n * ed25519PairFromRandom(); // => { secretKey: [...], publicKey: [...] }\n * ```\n */\nexport function ed25519PairFromRandom() {\n    return ed25519PairFromSeed(randomAsU8a());\n}\n","/**\n * @name ed25519PairFromSecret\n * @summary Creates a new public/secret keypair from a secret.\n * @description\n * Returns a object containing a `publicKey` & `secretKey` generated from the supplied secret.\n * @example\n * <BR>\n *\n * ```javascript\n * import { ed25519PairFromSecret } from '@polkadot/util-crypto';\n *\n * ed25519PairFromSecret(...); // => { secretKey: [...], publicKey: [...] }\n * ```\n */\nexport function ed25519PairFromSecret(secretKey) {\n    if (secretKey.length !== 64) {\n        throw new Error('Invalid secretKey provided');\n    }\n    return {\n        publicKey: secretKey.slice(32),\n        secretKey\n    };\n}\n","import { stringToU8a } from '@polkadot/util';\nimport { blake2AsU8a } from '../../blake2/asU8a.js';\nimport { ed25519PairFromSeed } from './fromSeed.js';\n/**\n * @name ed25519PairFromString\n * @summary Creates a new public/secret keypair from a string.\n * @description\n * Returns a object containing a `publicKey` & `secretKey` generated from the supplied string. The string is hashed and the value used as the input seed.\n * @example\n * <BR>\n *\n * ```javascript\n * import { ed25519PairFromString } from '@polkadot/util-crypto';\n *\n * ed25519PairFromString('test'); // => { secretKey: [...], publicKey: [...] }\n * ```\n */\nexport function ed25519PairFromString(value) {\n    return ed25519PairFromSeed(blake2AsU8a(stringToU8a(value)));\n}\n","import { u8aToU8a } from '@polkadot/util';\nimport { sr25519Agree } from '@polkadot/wasm-crypto';\n/**\n * @name sr25519Agreement\n * @description Key agreement between other's public key and self secret key\n */\nexport function sr25519Agreement(secretKey, publicKey) {\n    const secretKeyU8a = u8aToU8a(secretKey);\n    const publicKeyU8a = u8aToU8a(publicKey);\n    if (publicKeyU8a.length !== 32) {\n        throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);\n    }\n    else if (secretKeyU8a.length !== 64) {\n        throw new Error(`Invalid secretKey, received ${secretKeyU8a.length} bytes, expected 64`);\n    }\n    return sr25519Agree(publicKeyU8a, secretKeyU8a);\n}\n","import { isU8a, u8aToU8a } from '@polkadot/util';\nimport { sr25519DerivePublicSoft } from '@polkadot/wasm-crypto';\nexport function sr25519DerivePublic(publicKey, chainCode) {\n    const publicKeyU8a = u8aToU8a(publicKey);\n    if (!isU8a(chainCode) || chainCode.length !== 32) {\n        throw new Error('Invalid chainCode passed to derive');\n    }\n    else if (publicKeyU8a.length !== 32) {\n        throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);\n    }\n    return sr25519DerivePublicSoft(publicKeyU8a, chainCode);\n}\n","import { keyExtractPath } from '../key/index.js';\nimport { sr25519DerivePublic } from '../sr25519/index.js';\nimport { decodeAddress } from './decode.js';\nimport { encodeAddress } from './encode.js';\nfunction filterHard({ isHard }) {\n    return isHard;\n}\n/**\n * @name deriveAddress\n * @summary Creates a sr25519 derived address from the supplied and path.\n * @description\n * Creates a sr25519 derived address based on the input address/publicKey and the uri supplied.\n */\nexport function deriveAddress(who, suri, ss58Format) {\n    const { path } = keyExtractPath(suri);\n    if (!path.length || path.every(filterHard)) {\n        throw new Error('Expected suri to contain a combination of non-hard paths');\n    }\n    let publicKey = decodeAddress(who);\n    for (const { chainCode } of path) {\n        publicKey = sr25519DerivePublic(publicKey, chainCode);\n    }\n    return encodeAddress(publicKey, ss58Format);\n}\n","import { bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nimport { BN_LE_16_OPTS } from '../bn.js';\nimport { decodeAddress } from './decode.js';\nconst PREFIX = stringToU8a('modlpy/utilisuba');\nexport function createKeyDerived(who, index) {\n    return blake2AsU8a(u8aConcat(PREFIX, decodeAddress(who), bnToU8a(index, BN_LE_16_OPTS)));\n}\n","import { decodeAddress } from './decode.js';\nimport { encodeAddress } from './encode.js';\nimport { createKeyDerived } from './keyDerived.js';\n/**\n * @name encodeDerivedAddress\n * @summary Creates a derived address as used in Substrate utility.\n * @description\n * Creates a Substrate derived address based on the input address/publicKey and the index supplied.\n */\nexport function encodeDerivedAddress(who, index, ss58Format) {\n    return encodeAddress(createKeyDerived(decodeAddress(who), index), ss58Format);\n}\n","import { decodeAddress } from './decode.js';\nexport function addressToU8a(who) {\n    return decodeAddress(who);\n}\n","import { bnToU8a, compactToU8a, stringToU8a, u8aConcat, u8aSorted } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nimport { BN_LE_16_OPTS } from '../bn.js';\nimport { addressToU8a } from './util.js';\nconst PREFIX = stringToU8a('modlpy/utilisuba');\nexport function createKeyMulti(who, threshold) {\n    return blake2AsU8a(u8aConcat(PREFIX, compactToU8a(who.length), ...u8aSorted(who.map(addressToU8a)), bnToU8a(threshold, BN_LE_16_OPTS)));\n}\n","import { encodeAddress } from './encode.js';\nimport { createKeyMulti } from './keyMulti.js';\n/**\n * @name encodeMultiAddress\n * @summary Creates a multisig address.\n * @description\n * Creates a Substrate multisig address based on the input address and the required threshold.\n */\nexport function encodeMultiAddress(who, threshold, ss58Format) {\n    return encodeAddress(createKeyMulti(who, threshold), ss58Format);\n}\n","import { u8aEq } from '@polkadot/util';\nimport { decodeAddress } from './decode.js';\n/**\n * @name addressEq\n * @summary Compares two addresses, either in ss58, Uint8Array or hex format.\n * @description\n * For the input values, return true is the underlying public keys do match.\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aEq } from '@polkadot/util';\n *\n * u8aEq(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // true\n * ```\n */\nexport function addressEq(a, b) {\n    return u8aEq(decodeAddress(a), decodeAddress(b));\n}\n","import { u8aConcat } from '@polkadot/util';\nimport { hasher } from '../secp256k1/hasher.js';\nimport { encodeAddress } from './encode.js';\n/**\n * @name evmToAddress\n * @summary Converts an EVM address to its corresponding SS58 address.\n */\nexport function evmToAddress(evmAddress, ss58Format, hashType = 'blake2') {\n    const message = u8aConcat('evm:', evmAddress);\n    if (message.length !== 24) {\n        throw new Error(`Converting ${evmAddress}: Invalid evm address length`);\n    }\n    return encodeAddress(hasher(hashType, message), ss58Format);\n}\n","import { decodeAddress } from './decode.js';\nexport function validateAddress(encoded, ignoreChecksum, ss58Format) {\n    return !!decodeAddress(encoded, ignoreChecksum, ss58Format);\n}\n","import { validateAddress } from './validate.js';\nexport function isAddress(address, ignoreChecksum, ss58Format) {\n    try {\n        return validateAddress(address, ignoreChecksum, ss58Format);\n    }\n    catch {\n        return false;\n    }\n}\n","import { u8aSorted } from '@polkadot/util';\nimport { encodeAddress } from './encode.js';\nimport { addressToU8a } from './util.js';\nexport function sortAddresses(addresses, ss58Format) {\n    const u8aToAddress = (u8a) => encodeAddress(u8a, ss58Format);\n    return u8aSorted(addresses.map(addressToU8a)).map(u8aToAddress);\n}\n","import { utils } from '@scure/base';\nimport { createDecode, createEncode, createIs, createValidate } from './helpers.js';\nconst chars = 'abcdefghijklmnopqrstuvwxyz234567';\nconst config = {\n    chars,\n    coder: utils.chain(\n    // We define our own chain, the default base32 has padding\n    utils.radix2(5), utils.alphabet(chars), {\n        decode: (input) => input.split(''),\n        encode: (input) => input.join('')\n    }),\n    ipfs: 'b',\n    type: 'base32'\n};\n/**\n * @name base32Validate\n * @summary Validates a base32 value.\n * @description\n * Validates that the supplied value is valid base32, throwing exceptions if not\n */\nexport const base32Validate = /*#__PURE__*/ createValidate(config);\n/**\n* @name isBase32\n* @description Checks if the input is in base32, returning true/false\n*/\nexport const isBase32 = /*#__PURE__*/ createIs(base32Validate);\n/**\n * @name base32Decode\n * @summary Delookup a base32 value.\n * @description\n * From the provided input, decode the base32 and return the result as an `Uint8Array`.\n */\nexport const base32Decode = /*#__PURE__*/ createDecode(config, base32Validate);\n/**\n* @name base32Encode\n* @summary Creates a base32 value.\n* @description\n* From the provided input, create the base32 and return the result as a string.\n*/\nexport const base32Encode = /*#__PURE__*/ createEncode(config);\n","/**\n * @name base64Pad\n * @description Adds padding characters for correct length\n */\nexport function base64Pad(value) {\n    return value.padEnd(value.length + (value.length % 4), '=');\n}\n","/**\n * @name base64Trim\n * @description Trims padding characters\n */\nexport function base64Trim(value) {\n    while (value.length && value.endsWith('=')) {\n        value = value.slice(0, -1);\n    }\n    return value;\n}\n","import { hasBigInt } from '@polkadot/util';\nimport { bip39Generate, isReady } from '@polkadot/wasm-crypto';\nimport { generateMnemonic } from './bip39.js';\n/**\n * @name mnemonicGenerate\n * @summary Creates a valid mnemonic string using using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @example\n * <BR>\n *\n * ```javascript\n * import { mnemonicGenerate } from '@polkadot/util-crypto';\n *\n * const mnemonic = mnemonicGenerate(); // => string\n * ```\n */\nexport function mnemonicGenerate(numWords = 12, wordlist, onlyJs) {\n    return !hasBigInt || (!wordlist && !onlyJs && isReady())\n        ? bip39Generate(numWords)\n        : generateMnemonic(numWords, wordlist);\n}\n","import { BN_EIGHT, bnToU8a, u8aConcat, u8aToBn } from '@polkadot/util';\nimport { BN_LE_32_OPTS, BN_LE_512_OPTS, BN_LE_OPTS } from '../../bn.js';\nimport { hmacShaAsU8a } from '../../hmac/index.js';\nexport function ledgerDerivePrivate(xprv, index) {\n    const kl = xprv.subarray(0, 32);\n    const kr = xprv.subarray(32, 64);\n    const cc = xprv.subarray(64, 96);\n    const data = u8aConcat([0], kl, kr, bnToU8a(index, BN_LE_32_OPTS));\n    const z = hmacShaAsU8a(cc, data, 512);\n    data[0] = 0x01;\n    return u8aConcat(bnToU8a(u8aToBn(kl, BN_LE_OPTS).iadd(u8aToBn(z.subarray(0, 28), BN_LE_OPTS).imul(BN_EIGHT)), BN_LE_512_OPTS).subarray(0, 32), bnToU8a(u8aToBn(kr, BN_LE_OPTS).iadd(u8aToBn(z.subarray(32, 64), BN_LE_OPTS)), BN_LE_512_OPTS).subarray(0, 32), hmacShaAsU8a(cc, data, 512).subarray(32, 64));\n}\n","import { u8aConcat } from '@polkadot/util';\nimport { hmacShaAsU8a } from '../../hmac/index.js';\nimport { mnemonicToSeedSync } from '../../mnemonic/bip39.js';\nconst ED25519_CRYPTO = 'ed25519 seed';\nexport function ledgerMaster(mnemonic, password) {\n    const seed = mnemonicToSeedSync(mnemonic, password);\n    const chainCode = hmacShaAsU8a(ED25519_CRYPTO, new Uint8Array([1, ...seed]), 256);\n    let priv;\n    while (!priv || (priv[31] & 32)) {\n        priv = hmacShaAsU8a(ED25519_CRYPTO, priv || seed, 512);\n    }\n    priv[0] &= 248;\n    priv[31] &= 127;\n    priv[31] |= 64;\n    return u8aConcat(priv, chainCode);\n}\n","import { ed25519PairFromSeed } from '../../ed25519/index.js';\nimport { mnemonicValidate } from '../../mnemonic/index.js';\nimport { HARDENED, hdValidatePath } from '../validatePath.js';\nimport { ledgerDerivePrivate } from './derivePrivate.js';\nimport { ledgerMaster } from './master.js';\nexport function hdLedger(_mnemonic, path) {\n    const words = _mnemonic\n        .split(' ')\n        .map((s) => s.trim())\n        .filter((s) => s);\n    if (![12, 24, 25].includes(words.length)) {\n        throw new Error('Expected a mnemonic with 24 words (or 25 including a password)');\n    }\n    const [mnemonic, password] = words.length === 25\n        ? [words.slice(0, 24).join(' '), words[24]]\n        : [words.join(' '), ''];\n    if (!mnemonicValidate(mnemonic)) {\n        throw new Error('Invalid mnemonic passed to ledger derivation');\n    }\n    else if (!hdValidatePath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n    const parts = path.split('/').slice(1);\n    let seed = ledgerMaster(mnemonic, password);\n    for (const p of parts) {\n        const n = parseInt(p.replace(/'$/, ''), 10);\n        seed = ledgerDerivePrivate(seed, (n < HARDENED) ? (n + HARDENED) : n);\n    }\n    return ed25519PairFromSeed(seed.slice(0, 32));\n}\n","import { hexToU8a, isHex } from '@polkadot/util';\nimport { base64Decode } from '../base64/index.js';\nimport { jsonDecryptData } from './decryptData.js';\nexport function jsonDecrypt({ encoded, encoding }, passphrase) {\n    if (!encoded) {\n        throw new Error('No encrypted data available to decode');\n    }\n    return jsonDecryptData(isHex(encoded)\n        ? hexToU8a(encoded)\n        : base64Decode(encoded), passphrase, Array.isArray(encoding.type)\n        ? encoding.type\n        : [encoding.type]);\n}\n","import { u8aConcat } from '@polkadot/util';\nimport { naclEncrypt } from '../nacl/index.js';\nimport { scryptEncode, scryptToU8a } from '../scrypt/index.js';\nimport { jsonEncryptFormat } from './encryptFormat.js';\nexport function jsonEncrypt(data, contentType, passphrase) {\n    let isEncrypted = false;\n    let encoded = data;\n    if (passphrase) {\n        const { params, password, salt } = scryptEncode(passphrase);\n        const { encrypted, nonce } = naclEncrypt(encoded, password.subarray(0, 32));\n        isEncrypted = true;\n        encoded = u8aConcat(scryptToU8a(salt, params), nonce, encrypted);\n    }\n    return jsonEncryptFormat(encoded, contentType, isEncrypted);\n}\n"],"names":["u8aCmp","a","b","u8aa","u8aToU8a","u8ab","i","overA","overB","u8aSorted","u8as","packageInfo","others","netInfo","utilInfo","randomInfo","detectPackage","addressToEvm","address","ignoreChecksum","decodeAddress","checkAddress","prefix","decoded","base58Decode","error","isValid","ss58Decoded","checkAddressChecksum","defaults","BN_53","BN","randomAsNumber","hexToBn","randomAsHex","ed25519PairFromRandom","ed25519PairFromSeed","randomAsU8a","ed25519PairFromSecret","secretKey","ed25519PairFromString","value","blake2AsU8a","stringToU8a","sr25519Agreement","publicKey","secretKeyU8a","publicKeyU8a","sr25519Agree","sr25519DerivePublic","chainCode","isU8a","sr25519DerivePublicSoft","filterHard","isHard","deriveAddress","who","suri","ss58Format","path","keyExtractPath","encodeAddress","PREFIX","createKeyDerived","index","u8aConcat","bnToU8a","BN_LE_16_OPTS","encodeDerivedAddress","addressToU8a","createKeyMulti","threshold","compactToU8a","encodeMultiAddress","addressEq","u8aEq","evmToAddress","evmAddress","hashType","message","hasher","validateAddress","encoded","isAddress","sortAddresses","addresses","u8aToAddress","u8a","chars","config","utils","input","base32Validate","createValidate","isBase32","createIs","base32Decode","createDecode","base32Encode","createEncode","base64Pad","base64Trim","mnemonicGenerate","numWords","wordlist","onlyJs","hasBigInt","isReady","bip39Generate","generateMnemonic","ledgerDerivePrivate","xprv","kl","kr","cc","data","BN_LE_32_OPTS","z","hmacShaAsU8a","u8aToBn","BN_LE_OPTS","BN_EIGHT","BN_LE_512_OPTS","ED25519_CRYPTO","ledgerMaster","mnemonic","password","seed","mnemonicToSeedSync","priv","hdLedger","_mnemonic","words","s","mnemonicValidate","hdValidatePath","parts","p","n","HARDENED","jsonDecrypt","encoding","passphrase","jsonDecryptData","isHex","hexToU8a","base64Decode","jsonEncrypt","contentType","isEncrypted","params","salt","scryptEncode","encrypted","nonce","naclEncrypt","scryptToU8a","jsonEncryptFormat"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]}