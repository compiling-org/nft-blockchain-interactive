{"version":3,"file":"index-4ae20804.js","sources":["../../node_modules/@polkadot/keyring/detectOther.js","../../node_modules/@polkadot/keyring/packageInfo.js","../../node_modules/@polkadot/keyring/detectPackage.js","../../node_modules/@polkadot/keyring/pair/defaults.js","../../node_modules/@polkadot/keyring/pair/decode.js","../../node_modules/@polkadot/keyring/pair/encode.js","../../node_modules/@polkadot/keyring/pair/toJson.js","../../node_modules/@polkadot/keyring/pair/index.js","../../node_modules/@polkadot/keyring/defaults.js","../../node_modules/@polkadot/keyring/pairs.js","../../node_modules/@polkadot/keyring/keyring.js","../../node_modules/@polkadot/keyring/testing.js","../../node_modules/@polkadot/keyring/pair/nobody.js","../../node_modules/@polkadot/keyring/testingPairs.js"],"sourcesContent":["import { packageInfo as utilInfo } from '@polkadot/util/packageInfo';\nimport { packageInfo as cryptoInfo } from '@polkadot/util-crypto/packageInfo';\nexport default [utilInfo, cryptoInfo];\n","export const packageInfo = { name: '@polkadot/keyring', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '12.6.2' };\n","import { detectPackage } from '@polkadot/util';\nimport others from './detectOther.js';\nimport { packageInfo } from './packageInfo.js';\ndetectPackage(packageInfo, null, others);\n","export const PKCS8_DIVIDER = new Uint8Array([161, 35, 3, 33, 0]);\nexport const PKCS8_HEADER = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);\nexport const PUB_LENGTH = 32;\nexport const SALT_LENGTH = 32;\nexport const SEC_LENGTH = 64;\nexport const SEED_LENGTH = 32;\n","import { u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PKCS8_DIVIDER, PKCS8_HEADER, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from './defaults.js';\nconst SEED_OFFSET = PKCS8_HEADER.length;\nexport function decodePair(passphrase, encrypted, _encType) {\n    const encType = Array.isArray(_encType) || _encType === undefined\n        ? _encType\n        : [_encType];\n    const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n    const header = decrypted.subarray(0, PKCS8_HEADER.length);\n    if (!u8aEq(header, PKCS8_HEADER)) {\n        throw new Error('Invalid Pkcs8 header found in body');\n    }\n    let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n    let divOffset = SEED_OFFSET + SEC_LENGTH;\n    let divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);\n    // old-style, we have the seed here\n    if (!u8aEq(divider, PKCS8_DIVIDER)) {\n        divOffset = SEED_OFFSET + SEED_LENGTH;\n        secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n        divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);\n        if (!u8aEq(divider, PKCS8_DIVIDER)) {\n            throw new Error('Invalid Pkcs8 divider found in body');\n        }\n    }\n    const pubOffset = divOffset + PKCS8_DIVIDER.length;\n    const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n    return {\n        publicKey,\n        secretKey\n    };\n}\n","import { u8aConcat } from '@polkadot/util';\nimport { naclEncrypt, scryptEncode, scryptToU8a } from '@polkadot/util-crypto';\nimport { PKCS8_DIVIDER, PKCS8_HEADER } from './defaults.js';\nexport function encodePair({ publicKey, secretKey }, passphrase) {\n    if (!secretKey) {\n        throw new Error('Expected a valid secretKey to be passed to encode');\n    }\n    const encoded = u8aConcat(PKCS8_HEADER, secretKey, PKCS8_DIVIDER, publicKey);\n    if (!passphrase) {\n        return encoded;\n    }\n    const { params, password, salt } = scryptEncode(passphrase);\n    const { encrypted, nonce } = naclEncrypt(encoded, password.subarray(0, 32));\n    return u8aConcat(scryptToU8a(salt, params), nonce, encrypted);\n}\n","import { objectSpread } from '@polkadot/util';\nimport { jsonEncryptFormat } from '@polkadot/util-crypto';\nexport function pairToJson(type, { address, meta }, encoded, isEncrypted) {\n    return objectSpread(jsonEncryptFormat(encoded, ['pkcs8', type], isEncrypted), {\n        address,\n        meta\n    });\n}\n","import { objectSpread, u8aConcat, u8aEmpty, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ed25519PairFromSeed as ed25519FromSeed, ed25519Sign, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, secp256k1Compress, secp256k1Expand, secp256k1PairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify, sr25519PairFromSeed as sr25519FromSeed, sr25519Sign, sr25519VrfSign, sr25519VrfVerify } from '@polkadot/util-crypto';\nimport { decodePair } from './decode.js';\nimport { encodePair } from './encode.js';\nimport { pairToJson } from './toJson.js';\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n    ecdsa: secp256k1FromSeed,\n    ed25519: ed25519FromSeed,\n    ethereum: secp256k1FromSeed,\n    sr25519: sr25519FromSeed\n};\nconst TYPE_PREFIX = {\n    ecdsa: new Uint8Array([2]),\n    ed25519: new Uint8Array([0]),\n    ethereum: new Uint8Array([2]),\n    sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n    ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n    ed25519: ed25519Sign,\n    ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n    sr25519: sr25519Sign\n};\nconst TYPE_ADDRESS = {\n    ecdsa: (p) => p.length > 32 ? blake2AsU8a(p) : p,\n    ed25519: (p) => p,\n    ethereum: (p) => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n    sr25519: (p) => p\n};\nfunction isLocked(secretKey) {\n    return !secretKey || u8aEmpty(secretKey);\n}\nfunction vrfHash(proof, context, extra) {\n    return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\nexport function createPair({ toSS58, type }, { publicKey, secretKey }, meta = {}, encoded = null, encTypes) {\n    const decodePkcs8 = (passphrase, userEncoded) => {\n        const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n        if (decoded.secretKey.length === 64) {\n            publicKey = decoded.publicKey;\n            secretKey = decoded.secretKey;\n        }\n        else {\n            const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n            publicKey = pair.publicKey;\n            secretKey = pair.secretKey;\n        }\n    };\n    const recode = (passphrase) => {\n        isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n        encoded = encodePair({ publicKey, secretKey }, passphrase); // re-encode, latest version\n        encTypes = undefined; // swap to defaults, latest version follows\n        return encoded;\n    };\n    const encodeAddress = () => {\n        const raw = TYPE_ADDRESS[type](publicKey);\n        return type === 'ethereum'\n            ? ethereumEncode(raw)\n            : toSS58(raw);\n    };\n    return {\n        get address() {\n            return encodeAddress();\n        },\n        get addressRaw() {\n            const raw = TYPE_ADDRESS[type](publicKey);\n            return type === 'ethereum'\n                ? raw.slice(-20)\n                : raw;\n        },\n        get isLocked() {\n            return isLocked(secretKey);\n        },\n        get meta() {\n            return meta;\n        },\n        get publicKey() {\n            return publicKey;\n        },\n        get type() {\n            return type;\n        },\n        // eslint-disable-next-line sort-keys\n        decodePkcs8,\n        derive: (suri, meta) => {\n            if (type === 'ethereum') {\n                throw new Error('Unable to derive on this keypair');\n            }\n            else if (isLocked(secretKey)) {\n                throw new Error('Cannot derive on a locked keypair');\n            }\n            const { path } = keyExtractPath(suri);\n            const derived = keyFromPath({ publicKey, secretKey }, path, type);\n            return createPair({ toSS58, type }, derived, meta, null);\n        },\n        encodePkcs8: (passphrase) => {\n            return recode(passphrase);\n        },\n        lock: () => {\n            secretKey = new Uint8Array();\n        },\n        setMeta: (additional) => {\n            meta = objectSpread({}, meta, additional);\n        },\n        sign: (message, options = {}) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            return u8aConcat(options.withType\n                ? TYPE_PREFIX[type]\n                : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey }));\n        },\n        toJson: (passphrase) => {\n            // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n            // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n            // unless the publicKey is already an address\n            const address = ['ecdsa', 'ethereum'].includes(type)\n                ? publicKey.length === 20\n                    ? u8aToHex(publicKey)\n                    : u8aToHex(secp256k1Compress(publicKey))\n                : encodeAddress();\n            return pairToJson(type, { address, meta }, recode(passphrase), !!passphrase);\n        },\n        unlock: (passphrase) => {\n            return decodePkcs8(passphrase);\n        },\n        verify: (message, signature, signerPublic) => {\n            return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n        },\n        vrfSign: (message, context, extra) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            if (type === 'sr25519') {\n                return sr25519VrfSign(message, { secretKey }, context, extra);\n            }\n            const proof = TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey });\n            return u8aConcat(vrfHash(proof, context, extra), proof);\n        },\n        vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n            if (type === 'sr25519') {\n                return sr25519VrfVerify(message, vrfResult, publicKey, context, extra);\n            }\n            const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n            return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n        }\n    };\n}\n","export const DEV_PHRASE = 'bottom drive obey lake curtain smoke basket hold race lonely fit walk';\nexport const DEV_SEED = '0xfac7959dbfe72f052e5a0c3c8d6530f202b02fd8f9f5ca3580ec8deb7797479e';\n","import { isHex, isU8a, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nexport class Pairs {\n    __internal__map = {};\n    add(pair) {\n        this.__internal__map[decodeAddress(pair.address).toString()] = pair;\n        return pair;\n    }\n    all() {\n        return Object.values(this.__internal__map);\n    }\n    get(address) {\n        const pair = this.__internal__map[decodeAddress(address).toString()];\n        if (!pair) {\n            throw new Error(`Unable to retrieve keypair '${isU8a(address) || isHex(address)\n                ? u8aToHex(u8aToU8a(address))\n                : address}'`);\n        }\n        return pair;\n    }\n    remove(address) {\n        delete this.__internal__map[decodeAddress(address).toString()];\n    }\n}\n","import { hexToU8a, isHex, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, ed25519PairFromSeed as ed25519FromSeed, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, secp256k1PairFromSeed as secp256k1FromSeed, sr25519PairFromSeed as sr25519FromSeed } from '@polkadot/util-crypto';\nimport { createPair } from './pair/index.js';\nimport { DEV_PHRASE } from './defaults.js';\nimport { Pairs } from './pairs.js';\nconst PairFromSeed = {\n    ecdsa: (seed) => secp256k1FromSeed(seed),\n    ed25519: (seed) => ed25519FromSeed(seed),\n    ethereum: (seed) => secp256k1FromSeed(seed),\n    sr25519: (seed) => sr25519FromSeed(seed)\n};\nfunction pairToPublic({ publicKey }) {\n    return publicKey;\n}\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\nexport class Keyring {\n    __internal__pairs;\n    __internal__type;\n    __internal__ss58;\n    decodeAddress = decodeAddress;\n    constructor(options = {}) {\n        options.type = options.type || 'ed25519';\n        if (!['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined')) {\n            throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n        }\n        this.__internal__pairs = new Pairs();\n        this.__internal__ss58 = options.ss58Format;\n        this.__internal__type = options.type;\n    }\n    /**\n     * @description retrieve the pairs (alias for getPairs)\n     */\n    get pairs() {\n        return this.getPairs();\n    }\n    /**\n     * @description retrieve the publicKeys (alias for getPublicKeys)\n     */\n    get publicKeys() {\n        return this.getPublicKeys();\n    }\n    /**\n     * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n     */\n    get type() {\n        return this.__internal__type;\n    }\n    /**\n     * @name addPair\n     * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     */\n    addPair(pair) {\n        return this.__internal__pairs.add(pair);\n    }\n    /**\n     * @name addFromAddress\n     * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n     * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from them that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n        const publicKey = this.decodeAddress(address, ignoreChecksum);\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, { publicKey, secretKey: new Uint8Array() }, meta, encoded, encType));\n    }\n    /**\n     * @name addFromJson\n     * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromJson(json, ignoreChecksum) {\n        return this.addPair(this.createFromJson(json, ignoreChecksum));\n    }\n    /**\n     * @name addFromMnemonic\n     * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n     * argument and a metadata argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromMnemonic(mnemonic, meta = {}, type = this.type) {\n        return this.addFromUri(mnemonic, meta, type);\n    }\n    /**\n     * @name addFromPair\n     * @summary Stores an account created from an explicit publicKey/secreteKey combination\n     */\n    addFromPair(pair, meta = {}, type = this.type) {\n        return this.addPair(this.createFromPair(pair, meta, type));\n    }\n    /**\n     * @name addFromSeed\n     * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n     * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n     * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromSeed(seed, meta = {}, type = this.type) {\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, PairFromSeed[type](seed), meta, null));\n    }\n    /**\n     * @name addFromUri\n     * @summary Creates an account via an suri\n     * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n     */\n    addFromUri(suri, meta = {}, type = this.type) {\n        return this.addPair(this.createFromUri(suri, meta, type));\n    }\n    /**\n     * @name createFromJson\n     * @description Creates a pair from a JSON keyfile\n     */\n    createFromJson({ address, encoded, encoding: { content, type, version }, meta }, ignoreChecksum) {\n        if (version === '3' && content[0] !== 'pkcs8') {\n            throw new Error(`Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n        }\n        const cryptoType = version === '0' || !Array.isArray(content)\n            ? this.type\n            : content[1];\n        const encType = !Array.isArray(type)\n            ? [type]\n            : type;\n        if (!['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType)) {\n            throw new Error(`Unknown crypto type ${cryptoType}`);\n        }\n        // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n        const publicKey = isHex(address)\n            ? hexToU8a(address)\n            : this.decodeAddress(address, ignoreChecksum);\n        const decoded = isHex(encoded)\n            ? hexToU8a(encoded)\n            : base64Decode(encoded);\n        return createPair({ toSS58: this.encodeAddress, type: cryptoType }, { publicKey, secretKey: new Uint8Array() }, meta, decoded, encType);\n    }\n    /**\n     * @name createFromPair\n     * @summary Creates a pair from an explicit publicKey/secreteKey combination\n     */\n    createFromPair(pair, meta = {}, type = this.type) {\n        return createPair({ toSS58: this.encodeAddress, type }, pair, meta, null);\n    }\n    /**\n     * @name createFromUri\n     * @summary Creates a Keypair from an suri\n     * @description This creates a pair from the suri, but does not add it to the keyring\n     */\n    createFromUri(_suri, meta = {}, type = this.type) {\n        // here we only aut-add the dev phrase if we have a hard-derived path\n        const suri = _suri.startsWith('//')\n            ? `${DEV_PHRASE}${_suri}`\n            : _suri;\n        const { derivePath, password, path, phrase } = keyExtractSuri(suri);\n        let seed;\n        const isPhraseHex = isHex(phrase, 256);\n        if (isPhraseHex) {\n            seed = hexToU8a(phrase);\n        }\n        else {\n            const parts = phrase.split(' ');\n            if ([12, 15, 18, 21, 24].includes(parts.length)) {\n                seed = type === 'ethereum'\n                    ? mnemonicToLegacySeed(phrase, '', false, 64)\n                    : mnemonicToMiniSecret(phrase, password);\n            }\n            else {\n                if (phrase.length > 32) {\n                    throw new Error('specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n                }\n                seed = stringToU8a(phrase.padEnd(32));\n            }\n        }\n        const derived = type === 'ethereum'\n            ? isPhraseHex\n                ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n                : hdEthereum(seed, derivePath.substring(1))\n            : keyFromPath(PairFromSeed[type](seed), path, type);\n        return createPair({ toSS58: this.encodeAddress, type }, derived, meta, null);\n    }\n    /**\n     * @name encodeAddress\n     * @description Encodes the input into an ss58 representation\n     */\n    encodeAddress = (address, ss58Format) => {\n        return this.type === 'ethereum'\n            ? ethereumEncode(address)\n            : encodeAddress(address, ss58Format ?? this.__internal__ss58);\n    };\n    /**\n     * @name getPair\n     * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n     * @description Returns a keyring pair value from the keyring pair dictionary by performing\n     * a key lookup using the provided account address or public key (after decoding it).\n     */\n    getPair(address) {\n        return this.__internal__pairs.get(address);\n    }\n    /**\n     * @name getPairs\n     * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n     * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPairs() {\n        return this.__internal__pairs.all();\n    }\n    /**\n     * @name getPublicKeys\n     * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n     * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPublicKeys() {\n        return this.__internal__pairs.all().map(pairToPublic);\n    }\n    /**\n     * @name removePair\n     * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n     */\n    removePair(address) {\n        this.__internal__pairs.remove(address);\n    }\n    /**\n     * @name setSS58Format;\n     * @description Sets the ss58 format for the keyring\n     */\n    setSS58Format(ss58) {\n        this.__internal__ss58 = ss58;\n    }\n    /**\n     * @name toJson\n     * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n     * @description Returns a JSON object containing the metadata associated with an account\n     * when valid address or public key and when the account passphrase is provided if the account secret\n     * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n     * may backup their account to a JSON file that contains this information.\n     */\n    toJson(address, passphrase) {\n        return this.__internal__pairs.get(address).toJson(passphrase);\n    }\n}\n","import { hexToU8a } from '@polkadot/util';\nimport { createPair } from './pair/index.js';\nimport { Keyring } from './keyring.js';\nexport const PAIRSSR25519 = [\n    {\n        p: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',\n        s: '0x98319d4ff8a9508c4bb0cf0b5a78d760a0b2082c02775e6e82370816fedfff48925a225d97aa00682d6a59b95b18780c10d7032336e88f3442b42361f4a66011', // nosemgrep\n        seed: 'Alice',\n        type: 'sr25519'\n    },\n    {\n        p: '0xbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f',\n        s: '0xe8da6c9d810e020f5e3c7f5af2dea314cbeaa0d72bc6421e92c0808a0c584a6046ab28e97c3ffc77fe12b5a4d37e8cd4afbfebbf2391ffc7cb07c0f38c023efd', // nosemgrep\n        seed: 'Alice//stash',\n        type: 'sr25519'\n    },\n    {\n        p: '0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48',\n        s: '0x081ff694633e255136bdb456c20a5fc8fed21f8b964c11bb17ff534ce80ebd5941ae88f85d0c1bfc37be41c904e1dfc01de8c8067b0d6d5df25dd1ac0894a325', // nosemgrep\n        seed: 'Bob',\n        type: 'sr25519'\n    },\n    {\n        p: '0xfe65717dad0447d715f660a0a58411de509b42e6efb8375f562f58a554d5860e',\n        s: '0xc006507cdfc267a21532394c49ca9b754ca71de21e15a1cdf807c7ceab6d0b6c3ed408d9d35311540dcd54931933e67cf1ea10d46f75408f82b789d9bd212fde', // nosemgrep\n        seed: 'Bob//stash',\n        type: 'sr25519'\n    },\n    {\n        p: '0x90b5ab205c6974c9ea841be688864633dc9ca8a357843eeacf2314649965fe22',\n        s: '0xa8f2d83016052e5d6d77b2f6fd5d59418922a09024cda701b3c34369ec43a7668faf12ff39cd4e5d92bb773972f41a7a5279ebc2ed92264bed8f47d344f8f18c', // nosemgrep\n        seed: 'Charlie',\n        type: 'sr25519'\n    },\n    {\n        p: '0x306721211d5404bd9da88e0204360a1a9ab8b87c66c1bc2fcdd37f3c2222cc20',\n        s: '0x20e05482ca4677e0edbc58ae9a3a59f6ed3b1a9484ba17e64d6fe8688b2b7b5d108c4487b9323b98b11fe36cb301b084e920f7b7895536809a6d62a451b25568', // nosemgrep\n        seed: 'Dave',\n        type: 'sr25519'\n    },\n    {\n        p: '0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e',\n        s: '0x683576abfd5dc35273e4264c23095a1bf21c14517bece57c7f0cc5c0ed4ce06a3dbf386b7828f348abe15d76973a72009e6ef86a5c91db2990cb36bb657c6587', // nosemgrep\n        seed: 'Eve',\n        type: 'sr25519'\n    },\n    {\n        p: '0x1cbd2d43530a44705ad088af313e18f80b53ef16b36177cd4b77b846f2a5f07c',\n        s: '0xb835c20f450079cf4f513900ae9faf8df06ad86c681884122c752a4b2bf74d4303e4f21bc6cc62bb4eeed5a9cce642c25e2d2ac1464093b50f6196d78e3a7426', // nosemgrep\n        seed: 'Ferdie',\n        type: 'sr25519'\n    }\n];\nexport const PAIRSETHEREUM = [\n    {\n        name: 'Alith',\n        p: '0x02509540919faacf9ab52146c9aa40db68172d83777250b28e4679176e49ccdd9f',\n        s: '0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Baltathar',\n        p: '0x033bc19e36ff1673910575b6727a974a9abd80c9a875d41ab3e2648dbfb9e4b518',\n        s: '0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Charleth',\n        p: '0x0234637bdc0e89b5d46543bcbf8edff329d2702bc995e27e9af4b1ba009a3c2a5e',\n        s: '0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Dorothy',\n        p: '0x02a00d60b2b408c2a14c5d70cdd2c205db8985ef737a7e55ad20ea32cc9e7c417c',\n        s: '0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Ethan',\n        p: '0x025cdc005b752651cd3f728fb9192182acb3a9c89e19072cbd5b03f3ee1f1b3ffa',\n        s: '0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4', // nosemgrep\n        type: 'ethereum'\n    },\n    {\n        name: 'Faith',\n        p: '0x037964b6c9d546da4646ada28a99e34acaa1d14e7aba861a9055f9bd200c8abf74',\n        s: '0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df', // nosemgrep\n        type: 'ethereum'\n    }\n];\nfunction createMeta(name, seed) {\n    if (!name && !seed) {\n        throw new Error('Testing pair should have either a name or a seed');\n    }\n    return {\n        isTesting: true,\n        name: name || seed?.replace('//', '_').toLowerCase()\n    };\n}\n/**\n * @name testKeyring\n * @summary Create an instance of Keyring pre-populated with locked test accounts\n * @description The test accounts (i.e. alice, bob, dave, eve, ferdie)\n * are available on the dev chain and each test account is initialized with DOT funds.\n */\nexport function createTestKeyring(options = {}, isDerived = true) {\n    const keyring = new Keyring(options);\n    const pairs = options.type === 'ethereum'\n        ? PAIRSETHEREUM\n        : PAIRSSR25519;\n    for (const { name, p, s, seed, type } of pairs) {\n        const meta = createMeta(name, seed);\n        const pair = !isDerived && !name && seed\n            ? keyring.addFromUri(seed, meta, options.type)\n            : keyring.addPair(createPair({ toSS58: keyring.encodeAddress, type }, { publicKey: hexToU8a(p), secretKey: hexToU8a(s) }, meta));\n        pair.lock = () => {\n            // we don't have lock/unlock functionality here\n        };\n    }\n    return keyring;\n}\n","const publicKey = new Uint8Array(32);\nconst address = '5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM';\nconst meta = {\n    isTesting: true,\n    name: 'nobody'\n};\nconst json = {\n    address,\n    encoded: '',\n    encoding: {\n        content: ['pkcs8', 'ed25519'],\n        type: 'none',\n        version: '0'\n    },\n    meta\n};\nconst pair = {\n    address,\n    addressRaw: publicKey,\n    decodePkcs8: (_passphrase, _encoded) => undefined,\n    derive: (_suri, _meta) => pair,\n    encodePkcs8: (_passphrase) => new Uint8Array(0),\n    isLocked: true,\n    lock: () => {\n        // no locking, it is always locked\n    },\n    meta,\n    publicKey,\n    setMeta: (_meta) => undefined,\n    sign: (_message) => new Uint8Array(64),\n    toJson: (_passphrase) => json,\n    type: 'ed25519',\n    unlock: (_passphrase) => undefined,\n    verify: (_message, _signature) => false,\n    vrfSign: (_message, _context, _extra) => new Uint8Array(96),\n    vrfVerify: (_message, _vrfResult, _context, _extra) => false\n};\nexport function nobody() {\n    return pair;\n}\n","import { nobody } from './pair/nobody.js';\nimport { createTestKeyring } from './testing.js';\nexport function createTestPairs(options, isDerived = true) {\n    const keyring = createTestKeyring(options, isDerived);\n    const pairs = keyring.getPairs();\n    const map = { nobody: nobody() };\n    for (const p of pairs) {\n        if (p.meta.name) {\n            map[p.meta.name] = p;\n        }\n    }\n    return map;\n}\n"],"names":["others","utilInfo","cryptoInfo","packageInfo","detectPackage","PKCS8_DIVIDER","PKCS8_HEADER","PUB_LENGTH","SEC_LENGTH","SEED_LENGTH","SEED_OFFSET","decodePair","passphrase","encrypted","_encType","encType","decrypted","jsonDecryptData","header","u8aEq","secretKey","divOffset","divider","pubOffset","encodePair","publicKey","encoded","u8aConcat","params","password","salt","scryptEncode","nonce","naclEncrypt","scryptToU8a","pairToJson","type","address","meta","isEncrypted","objectSpread","jsonEncryptFormat","SIG_TYPE_NONE","TYPE_FROM_SEED","secp256k1FromSeed","ed25519FromSeed","sr25519FromSeed","TYPE_PREFIX","TYPE_SIGNATURE","m","p","secp256k1Sign","ed25519Sign","sr25519Sign","TYPE_ADDRESS","blake2AsU8a","keccakAsU8a","secp256k1Expand","isLocked","u8aEmpty","vrfHash","proof","context","extra","createPair","toSS58","encTypes","decodePkcs8","userEncoded","decoded","pair","recode","encodeAddress","raw","ethereumEncode","suri","path","keyExtractPath","derived","keyFromPath","additional","message","options","u8aToU8a","u8aToHex","secp256k1Compress","signature","signerPublic","signatureVerify","sr25519VrfSign","vrfResult","sr25519VrfVerify","DEV_PHRASE","DEV_SEED","Pairs","__publicField","decodeAddress","isU8a","isHex","PairFromSeed","seed","pairToPublic","Keyring","ss58Format","ignoreChecksum","json","mnemonic","content","version","cryptoType","hexToU8a","base64Decode","_suri","derivePath","phrase","keyExtractSuri","isPhraseHex","parts","mnemonicToLegacySeed","mnemonicToMiniSecret","stringToU8a","hdEthereum","ss58","PAIRSSR25519","PAIRSETHEREUM","createMeta","name","createTestKeyring","isDerived","keyring","pairs","s","_passphrase","_encoded","_meta","_message","_signature","_context","_extra","_vrfResult","nobody","createTestPairs","map"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}